from flask import Flask, render_template, request, redirect, url_for
from flask_sqlalchemy import SQLAlchemy
from jira_renderer import JiraRenderer
import mistletoe, os 

app = Flask(__name__)

# Configure SQLite database
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bug_reports.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Database model for storing bug reports
class BugReport(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)  # A simple title to display in the UI
    jira_output = db.Column(db.Text, nullable=False)  # Store the Jira-formatted bug report

# Initialize the database (create the tables) manually
def init_db():
    db.create_all()

@app.route("/", methods=["GET", "POST"])
def index():
    if request.method == "POST":
        # Retrieve form data
        bugtype_text = request.form.get("bug_type")
        cvssvector_text = request.form.get("cvss_vector")
        cvssscore_text = request.form.get("cvss_score")
        scope_text = request.form.get("scope")
        endpoint_text = request.form.get("endpoint")
        observation_text = request.form.get("observation")
        poc_text = request.form.get("poc")  # PoC is now part of the description
        impact_text = request.form.get("impact")
        recommendation_text = request.form.get("recommendation")
        references_text = request.form.get("references")
        title = request.form.get("title")  # Add a title for the report

        # Build description_text with proper labels, including PoC
        description_text = (
            f"### Bug Type:\n{bugtype_text}\n\n"
            f"### CVSS Vector:\n{cvssvector_text}\n\n"
            f"### CVSS Score:\n{cvssscore_text}\n\n"
            f"### Scope:\n{scope_text}\n\n"
            f"### Endpoint:\n{endpoint_text}\n\n"
            f"### Observation:\n{observation_text}\n\n"
            f"### PoC:\n{poc_text}\n\n"
            f"### Impact:\n{impact_text}\n\n"
            f"### Recommendation:\n{recommendation_text}\n\n"
            f"### References:\n{references_text}"
        )

        # Render Jira output using mistletoe and JiraRenderer
        with JiraRenderer() as renderer:
            jira_output = renderer.render(mistletoe.Document(description_text))

        # Save the bug report to the database
        new_bug_report = BugReport(title=title, jira_output=jira_output)
        db.session.add(new_bug_report)
        db.session.commit()

        return redirect(url_for('index'))

    # Retrieve all bug reports to display in the UI
    bug_reports = BugReport.query.all()

    return render_template("index.html", bug_reports=bug_reports)

@app.route("/report/<int:report_id>")
def report(report_id):
    # Retrieve the specific bug report by ID
    bug_report = BugReport.query.get_or_404(report_id)
    return render_template("report.html", bug_report=bug_report)

# New route to edit a report
@app.route("/edit/<int:report_id>", methods=["GET", "POST"])
def edit_report(report_id):
    bug_report = BugReport.query.get_or_404(report_id)


    if request.method == 'POST':
        # Update the report with the new data from the form
        bug_report.title = request.form['title']
        bug_report.bug_type = request.form['bug_type']
        bug_report.cvss_vector = request.form['cvss_vector']
        bug_report.cvss_score = request.form['cvss_score']
        bug_report.scope = request.form['scope']
        bug_report.endpoint = request.form['endpoint']
        bug_report.observation = request.form['observation']
        bug_report.poc = request.form['poc']
        bug_report.impact = request.form['impact']
        bug_report.recommendation = request.form['recommendation']
        bug_report.references = request.form['references']

        # Save the updated report back to the database
        db.session.commit()

        # Re-render Jira output
        with JiraRenderer() as renderer:
            bug_report.jira_output = renderer.render(mistletoe.Document(description_text))

        # Commit the changes to the database
        db.session.commit()

        return redirect(url_for('index'))

    # Render the edit form with the current report data pre-filled
    return render_template("edit_report.html", bug_report=bug_report)

@app.route("/delete/<int:report_id>", methods=["POST", "GET"])
def delete_report(report_id):
    # Retrieve the specific bug report by ID
    bug_report = BugReport.query.get_or_404(report_id)

    # Delete the report from the database
    db.session.delete(bug_report)
    db.session.commit()

    # Redirect back to the main page after deletion
    return redirect(url_for('index'))

# Define and ensure the upload folder exists
UPLOAD_FOLDER = os.path.join(os.getcwd(), 'uploads')
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# Set the upload folder in app configuration
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Set max file size to 16MB

# Allowed file extensions for uploads
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

# Helper function to check allowed file types
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


# Route for uploading files
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        file_url = url_for('uploaded_file', filename=filename, _external=True)
        return jsonify({'url': file_url}), 200
    return jsonify({'error': 'File type not allowed'}), 400

# Route to display all uploaded images
@app.route('/uploaded_images')
def uploaded_images():
    # List all files in the upload folder
    uploaded_files = os.listdir(app.config['UPLOAD_FOLDER'])
    image_urls = [
        url_for('uploaded_file', filename=f, _external=True)
        for f in uploaded_files if allowed_file(f)
    ]
    return render_template('uploaded_images.html', images=image_urls)

# Route to serve uploaded files
@app.route('/uploads/<filename>')
def uploaded_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

# Updated route for upload form
@app.route('/upload_page')
def upload_page():
    return '''
        <h1>Upload a new Image</h1>
        <form method="post" action="/upload" enctype="multipart/form-data">
            <input type="file" name="file">
            <input type="submit" value="Upload">
        </form>
        <a href="/uploaded_images">View uploaded images</a>
    '''


if __name__ == "__main__":
    # Initialize the database tables
    with app.app_context():
        init_db()

    # Run the Flask app
    app.run(debug=True) 